# HG changeset patch
# Parent 8ba09912a060f2d6ec4582913794d06e459627b6
# User Joe Walker <jwalker@mozilla.com>
Bug 690822 - GCLI web tests should be capable of being run in the browser

diff --git a/browser/devtools/webconsole/test/browser/Makefile.in b/browser/devtools/webconsole/test/browser/Makefile.in
--- a/browser/devtools/webconsole/test/browser/Makefile.in
+++ b/browser/devtools/webconsole/test/browser/Makefile.in
@@ -147,6 +147,7 @@ _BROWSER_TEST_FILES = \
 	browser_webconsole_bug_664131_console_group.js \
 	browser_gcli_require.js \
 	browser_gcli_integrate.js \
+	browser_gcli_web.js \
 	head.js \
 	$(NULL)
 
diff --git a/browser/devtools/webconsole/test/browser/browser_gcli_web.js b/browser/devtools/webconsole/test/browser/browser_gcli_web.js
new file mode 100644
--- /dev/null
+++ b/browser/devtools/webconsole/test/browser/browser_gcli_web.js
@@ -0,0 +1,1401 @@
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+/*
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *********************************** WARNING ***********************************
+ *
+ * Do not edit this file without understanding where it comes from,
+ * Your changes are likely to be overwritten without warning.
+ *
+ * This test file is generated using a level 25 wizard spell cast on the
+ * test files that run in the browser as part of GCLI's test suite.
+ * For details of how to cast the spell, see GCLI's Makefile.dryice.js
+ *
+ * For more information on GCLI see:
+ * - https://github.com/mozilla/gcli/blob/master/docs/index.md
+ * - https://wiki.mozilla.org/DevTools/Features/GCLI
+ *
+ * The original source for this file is:
+ *  https://github.com/mozilla/gcli/
+ *
+ *******************************************************************************
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ *
+ */
+
+///////////////////////////////////////////////////////////////////////////////
+
+var obj = {};
+Components.utils.import("resource:///modules/gcli.jsm", obj);
+
+var define = obj.gcli._internal.define;
+var console = obj.gcli._internal.console;
+var Node = Components.interfaces.nsIDOMNode;
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/index', ['require', 'exports', 'module' , 'test/examiner', 'gclitest/testTokenize', 'gclitest/testSplit', 'gclitest/testCli', 'gclitest/testHistory', 'gclitest/testRequire'], function(require, exports, module) {
+
+  var examiner = require('test/examiner');
+
+  examiner.addSuite('gclitest/testTokenize', require('gclitest/testTokenize'));
+  examiner.addSuite('gclitest/testSplit', require('gclitest/testSplit'));
+  examiner.addSuite('gclitest/testCli', require('gclitest/testCli'));
+  examiner.addSuite('gclitest/testHistory', require('gclitest/testHistory'));
+
+  examiner.addSuite('gclitest/testRequire', require('gclitest/testRequire'));
+
+  examiner.run();
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('test/examiner', ['require', 'exports', 'module' ], function(require, exports, module) {
+var examiner = exports;
+
+
+/**
+ * Test harness data
+ */
+examiner.suites = {};
+
+/**
+ * The gap between tests when running async
+ */
+var delay = 10;
+
+var currentTest = null;
+
+var stati = {
+  notrun: { index: 0, name: 'Skipped' },
+  executing: { index: 1, name: 'Executing' },
+  asynchronous: { index: 2, name: 'Waiting' },
+  pass: { index: 3, name: 'Pass' },
+  fail: { index: 4, name: 'Fail' }
+};
+
+/**
+ * Add a test suite. Generally used like:
+ * test.addSuite('foo', require('path/to/foo'));
+ */
+examiner.addSuite = function(name, suite) {
+  examiner.suites[name] = new Suite(name, suite);
+};
+
+/**
+ * Run all the tests synchronously
+ */
+examiner.run = function() {
+  Object.keys(examiner.suites).forEach(function(suiteName) {
+    var suite = examiner.suites[suiteName];
+    suite.run();
+  }.bind(this));
+  return examiner.suites;
+};
+
+/**
+ * Run all the tests asynchronously
+ */
+examiner.runAsync = function(callback) {
+  this.runAsyncInternal(0, callback);
+};
+
+/**
+ * Run all the test suits asynchronously
+ */
+examiner.runAsyncInternal = function(i, callback) {
+  if (i >= Object.keys(examiner.suites).length) {
+    if (typeof callback === 'function') {
+      callback();
+    }
+    return;
+  }
+
+  var suiteName = Object.keys(examiner.suites)[i];
+  examiner.suites[suiteName].runAsync(function() {
+    setTimeout(function() {
+      examiner.runAsyncInternal(i + 1, callback);
+    }.bind(this), delay);
+  }.bind(this));
+};
+
+/**
+ *
+ */
+examiner.reportToText = function() {
+  return JSON.stringify(examiner.toRemote());
+};
+
+/**
+ * Create a JSON object suitable for serialization
+ */
+examiner.toRemote = function() {
+  return {
+    suites: Object.keys(examiner.suites).map(function(suiteName) {
+      return examiner.suites[suiteName].toRemote();
+    }.bind(this))
+  };
+};
+
+/**
+ * Used by assert to record a failure against the current test
+ */
+examiner.recordError = function(message) {
+  if (!currentTest) {
+    console.error('No currentTest for ' + message);
+    return;
+  }
+
+  currentTest.status = stati.fail;
+
+  if (Array.isArray(message)) {
+    currentTest.messages.push.apply(currentTest.messages, message);
+  }
+  else {
+    currentTest.messages.push(message);
+  }
+};
+
+/**
+ * A suite is a group of tests
+ */
+function Suite(suiteName, suite) {
+  this.name = suiteName;
+  this.suite = suite;
+
+  this.tests = {};
+  Object.keys(suite).forEach(function(testName) {
+    if (testName !== 'setup' && testName !== 'shutdown') {
+      var test = new Test(this, testName, suite[testName]);
+      this.tests[testName] = test;
+    }
+  }.bind(this));
+}
+
+/**
+ * Run all the tests in this suite synchronously
+ */
+Suite.prototype.run = function() {
+  if (typeof this.suite.setup == "function") {
+    this.suite.setup();
+  }
+
+  Object.keys(this.tests).forEach(function(testName) {
+    var test = this.tests[testName];
+    test.run();
+  }.bind(this));
+
+  if (typeof this.suite.shutdown == "function") {
+    this.suite.shutdown();
+  }
+};
+
+/**
+ * Run all the tests in this suite asynchronously
+ */
+Suite.prototype.runAsync = function(callback) {
+  if (typeof this.suite.setup == "function") {
+    this.suite.setup();
+  }
+
+  this.runAsyncInternal(0, function() {
+    if (typeof this.suite.shutdown == "function") {
+      this.suite.shutdown();
+    }
+
+    if (typeof callback === 'function') {
+      callback();
+    }
+  }.bind(this));
+};
+
+/**
+ * Function used by the async runners that can handle async recursion.
+ */
+Suite.prototype.runAsyncInternal = function(i, callback) {
+  if (i >= Object.keys(this.tests).length) {
+    if (typeof callback === 'function') {
+      callback();
+    }
+    return;
+  }
+
+  var testName = Object.keys(this.tests)[i];
+  this.tests[testName].runAsync(function() {
+    setTimeout(function() {
+      this.runAsyncInternal(i + 1, callback);
+    }.bind(this), delay);
+  }.bind(this));
+};
+
+/**
+ * Create a JSON object suitable for serialization
+ */
+Suite.prototype.toRemote = function() {
+  return {
+    name: this.name,
+    tests: Object.keys(this.tests).map(function(testName) {
+      return this.tests[testName].toRemote();
+    }.bind(this))
+  };
+};
+
+
+/**
+ * A test represents data about a single test function
+ */
+function Test(suite, name, func) {
+  this.suite = suite;
+  this.name = name;
+  this.func = func;
+  this.title = name.replace(/^test/, '').replace(/([A-Z])/g, ' $1');
+
+  this.messages = [];
+  this.status = stati.notrun;
+}
+
+/**
+ * Run just a single test
+ */
+Test.prototype.run = function() {
+  currentTest = this;
+  this.status = stati.executing;
+  this.messages = [];
+
+  try {
+    this.func.apply(this.suite);
+  }
+  catch (ex) {
+    this.status = stati.fail;
+    this.messages.push('' + ex);
+    console.error(ex);
+    console.trace();
+  }
+
+  if (this.status === stati.executing) {
+    this.status = stati.pass;
+  }
+
+  currentTest = null;
+};
+
+/**
+ * Run all the tests in this suite asynchronously
+ */
+Test.prototype.runAsync = function(callback) {
+  setTimeout(function() {
+    this.run();
+    if (typeof callback === 'function') {
+      callback();
+    }
+  }.bind(this), delay);
+};
+
+/**
+ * Create a JSON object suitable for serialization
+ */
+Test.prototype.toRemote = function() {
+  return {
+    name: this.name,
+    title: this.title,
+    status: this.status,
+    messages: this.messages
+  };
+};
+
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/testTokenize', ['require', 'exports', 'module' , 'test/assert', 'gcli/cli', 'gcli/argument'], function(require, exports, module) {
+
+
+var test = require('test/assert');
+var Requisition = require('gcli/cli').Requisition;
+var Argument = require('gcli/argument').Argument;
+var ScriptArgument = require('gcli/argument').ScriptArgument;
+
+exports.testBlanks = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('');
+  test.is(1, args.length);
+  test.is('', args[0].text);
+  test.is('', args[0].prefix);
+  test.is('', args[0].suffix);
+
+  args = requ._tokenize(' ');
+  test.is(1, args.length);
+  test.is('', args[0].text);
+  test.is(' ', args[0].prefix);
+  test.is('', args[0].suffix);
+};
+
+exports.testSimple = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('s');
+  test.is(1, args.length);
+  test.is('s', args[0].text);
+  test.is('', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+
+  args = requ._tokenize('s s');
+  test.is(2, args.length);
+  test.is('s', args[0].text);
+  test.is('', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+  test.is('s', args[1].text);
+  test.is(' ', args[1].prefix);
+  test.is('', args[1].suffix);
+  test.ok(args[1] instanceof Argument);
+};
+
+exports.testJavascript = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('{x}');
+  test.is(1, args.length);
+  test.is('x', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{ x }');
+  test.is(1, args.length);
+  test.is('x', args[0].text);
+  test.is('{ ', args[0].prefix);
+  test.is(' }', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{x} {y}');
+  test.is(2, args.length);
+  test.is('x', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+  test.is('y', args[1].text);
+  test.is(' {', args[1].prefix);
+  test.is('}', args[1].suffix);
+  test.ok(args[1] instanceof ScriptArgument);
+
+  args = requ._tokenize('{x}{y}');
+  test.is(2, args.length);
+  test.is('x', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+  test.is('y', args[1].text);
+  test.is('{', args[1].prefix);
+  test.is('}', args[1].suffix);
+  test.ok(args[1] instanceof ScriptArgument);
+
+  args = requ._tokenize('{');
+  test.is(1, args.length);
+  test.is('', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{ ');
+  test.is(1, args.length);
+  test.is('', args[0].text);
+  test.is('{ ', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{x');
+  test.is(1, args.length);
+  test.is('x', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+};
+
+exports.testRegularNesting = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('{"x"}');
+  test.is(1, args.length);
+  test.is('"x"', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{\'x\'}');
+  test.is(1, args.length);
+  test.is('\'x\'', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('"{x}"');
+  test.is(1, args.length);
+  test.is('{x}', args[0].text);
+  test.is('"', args[0].prefix);
+  test.is('"', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+
+  args = requ._tokenize('\'{x}\'');
+  test.is(1, args.length);
+  test.is('{x}', args[0].text);
+  test.is('\'', args[0].prefix);
+  test.is('\'', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+};
+
+exports.testDeepNesting = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('{{}}');
+  test.is(1, args.length);
+  test.is('{}', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{{x} {y}}');
+  test.is(1, args.length);
+  test.is('{x} {y}', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  args = requ._tokenize('{{w} {{{x}}}} {y} {{{z}}}');
+
+  test.is(3, args.length);
+
+  test.is('{w} {{{x}}}', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  test.is('y', args[1].text);
+  test.is(' {', args[1].prefix);
+  test.is('}', args[1].suffix);
+  test.ok(args[1] instanceof ScriptArgument);
+
+  test.is('{{z}}', args[2].text);
+  test.is(' {', args[2].prefix);
+  test.is('}', args[2].suffix);
+  test.ok(args[2] instanceof ScriptArgument);
+
+  args = requ._tokenize('{{w} {{{x}}} {y} {{{z}}}');
+
+  test.is(1, args.length);
+
+  test.is('{w} {{{x}}} {y} {{{z}}}', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+};
+
+exports.testStrangeNesting = function() {
+  var args;
+  var requ = new Requisition();
+
+  // Note: When we get real JS parsing this should break
+  args = requ._tokenize('{"x}"}');
+
+  test.is(2, args.length);
+
+  test.is('"x', args[0].text);
+  test.is('{', args[0].prefix);
+  test.is('}', args[0].suffix);
+  test.ok(args[0] instanceof ScriptArgument);
+
+  test.is('}', args[1].text);
+  test.is('"', args[1].prefix);
+  test.is('', args[1].suffix);
+  test.ok(args[1] instanceof Argument);
+};
+
+exports.testComplex = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize(' 1234  \'12 34\'');
+
+  test.is(2, args.length);
+
+  test.is('1234', args[0].text);
+  test.is(' ', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+
+  test.is('12 34', args[1].text);
+  test.is('  \'', args[1].prefix);
+  test.is('\'', args[1].suffix);
+  test.ok(args[1] instanceof Argument);
+
+  args = requ._tokenize('12\'34 "12 34" \\'); // 12'34 "12 34" \
+
+  test.is(3, args.length);
+
+  test.is('12\'34', args[0].text);
+  test.is('', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+
+  test.is('12 34', args[1].text);
+  test.is(' "', args[1].prefix);
+  test.is('"', args[1].suffix);
+  test.ok(args[1] instanceof Argument);
+
+  test.is('\\', args[2].text);
+  test.is(' ', args[2].prefix);
+  test.is('', args[2].suffix);
+  test.ok(args[2] instanceof Argument);
+};
+
+exports.testPathological = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('a\\ b \\t\\n\\r \\\'x\\\" \'d'); // a_b \t\n\r \'x\" 'd
+
+  test.is(4, args.length);
+
+  test.is('a b', args[0].text);
+  test.is('', args[0].prefix);
+  test.is('', args[0].suffix);
+  test.ok(args[0] instanceof Argument);
+
+  test.is('\t\n\r', args[1].text);
+  test.is(' ', args[1].prefix);
+  test.is('', args[1].suffix);
+  test.ok(args[1] instanceof Argument);
+
+  test.is('\'x"', args[2].text);
+  test.is(' ', args[2].prefix);
+  test.is('', args[2].suffix);
+  test.ok(args[2] instanceof Argument);
+
+  test.is('d', args[3].text);
+  test.is(' \'', args[3].prefix);
+  test.is('', args[3].suffix);
+  test.ok(args[3] instanceof Argument);
+};
+
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('test/assert', ['require', 'exports', 'module' ], function(require, exports, module) {
+
+  exports.ok = ok;
+  exports.is = is;
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/testSplit', ['require', 'exports', 'module' , 'test/assert', 'gclitest/commands', 'gcli/cli'], function(require, exports, module) {
+
+var test = require('test/assert');
+
+var commands = require('gclitest/commands');
+var Requisition = require('gcli/cli').Requisition;
+
+exports.setup = function() {
+  commands.setup();
+};
+
+exports.shutdown = function() {
+  commands.shutdown();
+};
+
+exports.testSimple = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('s');
+  requ._split(args);
+  test.is(0, args.length);
+  test.is('s', requ.commandAssignment.getArg().text);
+};
+
+exports.testFlatCommand = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('tsv');
+  requ._split(args);
+  test.is(0, args.length);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+
+  args = requ._tokenize('tsv a b');
+  requ._split(args);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is(2, args.length);
+  test.is('a', args[0].text);
+  test.is('b', args[1].text);
+};
+
+exports.testJavascript = function() {
+  var args;
+  var requ = new Requisition();
+
+  args = requ._tokenize('{');
+  requ._split(args);
+  test.is(1, args.length);
+  test.is('', args[0].text);
+  test.is('', requ.commandAssignment.getArg().text);
+  test.is('{', requ.commandAssignment.getValue().name);
+};
+
+// BUG 663081 - add tests for sub commands
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/commands', ['require', 'exports', 'module' , 'gcli/canon', 'gcli/types/basic', 'gcli/types'], function(require, exports, module) {
+var commands = exports;
+
+
+var canon = require('gcli/canon');
+
+var SelectionType = require('gcli/types/basic').SelectionType;
+var DeferredType = require('gcli/types/basic').DeferredType;
+var types = require('gcli/types');
+
+/**
+ * Registration and de-registration.
+ */
+commands.setup = function() {
+  commands.option1.type = types.getType('number');
+  commands.option2.type = types.getType('boolean');
+
+  types.registerType(commands.optionType);
+  types.registerType(commands.optionValue);
+
+  canon.addCommand(commands.tsv);
+  canon.addCommand(commands.tsr);
+  canon.addCommand(commands.tsu);
+  canon.addCommand(commands.tsn);
+  canon.addCommand(commands.tsnDif);
+  canon.addCommand(commands.tsnExt);
+  canon.addCommand(commands.tsnExte);
+  canon.addCommand(commands.tsnExten);
+  canon.addCommand(commands.tsnExtend);
+  canon.addCommand(commands.tselarr);
+  canon.addCommand(commands.tsm);
+};
+
+commands.shutdown = function() {
+  canon.removeCommand(commands.tsv);
+  canon.removeCommand(commands.tsr);
+  canon.removeCommand(commands.tsu);
+  canon.removeCommand(commands.tsn);
+  canon.removeCommand(commands.tsnDif);
+  canon.removeCommand(commands.tsnExt);
+  canon.removeCommand(commands.tsnExte);
+  canon.removeCommand(commands.tsnExten);
+  canon.removeCommand(commands.tsnExtend);
+  canon.removeCommand(commands.tselarr);
+  canon.removeCommand(commands.tsm);
+
+  types.deregisterType(commands.optionType);
+  types.deregisterType(commands.optionValue);
+};
+
+
+commands.option1 = { };
+commands.option2 = { };
+
+commands.optionType = new SelectionType({
+  name: 'optionType',
+  lookup: [
+    { name: 'option1', value: commands.option1 },
+    { name: 'option2', value: commands.option2 }
+  ],
+  noMatch: function() {
+    this.lastOption = null;
+  },
+  stringify: function(option) {
+    this.lastOption = option;
+    return SelectionType.prototype.stringify.call(this, option);
+  },
+  parse: function(arg) {
+    var conversion = SelectionType.prototype.parse.call(this, arg);
+    this.lastOption = conversion.value;
+    return conversion;
+  }
+});
+
+commands.optionValue = new DeferredType({
+  name: 'optionValue',
+  defer: function() {
+    if (commands.optionType.lastOption) {
+      return commands.optionType.lastOption.type;
+    }
+    else {
+      return types.getType('blank');
+    }
+  }
+});
+
+commands.tsv = {
+  name: 'tsv',
+  params: [
+    { name: 'optionType', type: 'optionType' },
+    { name: 'optionValue', type: 'optionValue' }
+  ],
+  exec: function(args, context) { }
+};
+
+commands.tsr = {
+  name: 'tsr',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(args, context) { }
+};
+
+commands.tsu = {
+  name: 'tsu',
+  params: [ { name: 'num', type: 'number' } ],
+  exec: function(args, context) { }
+};
+
+commands.tsn = {
+  name: 'tsn'
+};
+
+commands.tsnDif = {
+  name: 'tsn dif',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(text) { }
+};
+
+commands.tsnExt = {
+  name: 'tsn ext',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(text) { }
+};
+
+commands.tsnExte = {
+  name: 'tsn exte',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(text) { }
+};
+
+commands.tsnExten = {
+  name: 'tsn exten',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(text) { }
+};
+
+commands.tsnExtend = {
+  name: 'tsn extend',
+  params: [ { name: 'text', type: 'string' } ],
+  exec: function(text) { }
+};
+
+commands.tselarr = {
+  name: 'tselarr',
+  params: [
+    { name: 'num', type: { name: 'selection', data: [ '1', '2', '3' ] } },
+    { name: 'arr', type: { name: 'array', subtype: 'string' } },
+  ],
+  exec: function(args, context) {}
+};
+
+commands.tsm = {
+  name: 'tsm',
+  hidden: true,
+  description: 'a 3-param test selection|string|number',
+  params: [
+    { name: 'abc', type: { name: 'selection', data: [ 'a', 'b', 'c' ] } },
+    { name: 'txt', type: 'string' },
+    { name: 'num', type: { name: 'number', max: 42, min: 0 } },
+  ],
+  exec: function(args, context) {}
+};
+
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/testCli', ['require', 'exports', 'module' , 'gcli/cli', 'gcli/types', 'gclitest/commands', 'test/assert'], function(require, exports, module) {
+
+
+var Requisition = require('gcli/cli').Requisition;
+var Status = require('gcli/types').Status;
+var commands = require('gclitest/commands');
+
+var test = require('test/assert');
+
+exports.setup = function() {
+  commands.setup();
+};
+
+exports.shutdown = function() {
+  commands.shutdown();
+};
+
+
+var assign1;
+var assign2;
+var assignC;
+var requ;
+var debug = false;
+var status;
+var statuses;
+
+function update(input) {
+  if (!requ) {
+    requ = new Requisition();
+  }
+  requ.update(input);
+
+  if (debug) {
+    console.log('####### TEST: typed="' + input.typed +
+        '" cur=' + input.cursor.start +
+        ' cli=', requ);
+  }
+
+  status = requ.getStatus();
+  assignC = requ.getAssignmentAt(input.cursor.start);
+  statuses = requ.getInputStatusMarkup().map(function(s) {
+    return s.toString()[0];
+  }).join('');
+
+  if (requ.commandAssignment.getValue()) {
+    assign1 = requ.getAssignment(0);
+    assign2 = requ.getAssignment(1);
+  }
+  else {
+    assign1 = undefined;
+    assign2 = undefined;
+  }
+}
+
+function verifyPredictionsContains(name, predictions) {
+  return predictions.every(function(prediction) {
+    return name === prediction.name;
+  }, this);
+}
+
+
+exports.testBlank = function() {
+  update({ typed: '', cursor: { start: 0, end: 0 } });
+  test.is(   '', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is(null, requ.commandAssignment.getValue());
+
+  update({ typed: ' ', cursor: { start: 1, end: 1 } });
+  test.is(   'V', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is(null, requ.commandAssignment.getValue());
+
+  update({ typed: ' ', cursor: { start: 0, end: 0 } });
+  test.is(   'V', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is(null, requ.commandAssignment.getValue());
+};
+
+exports.testIncompleteMultiMatch = function() {
+  update({ typed: 't', cursor: { start: 1, end: 1 } });
+  test.is(   'I', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.ok(assignC.getPredictions().length > 0);
+  test.ok(assignC.getPredictions().length < 20); // could break ...
+  verifyPredictionsContains('tsv', assignC.getPredictions());
+  verifyPredictionsContains('tsr', assignC.getPredictions());
+  test.is(null, requ.commandAssignment.getValue());
+};
+
+exports.testIncompleteSingleMatch = function() {
+  update({ typed: 'tselar', cursor: { start: 6, end: 6 } });
+  test.is(   'IIIIII', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is(1, assignC.getPredictions().length);
+  test.is('tselarr', assignC.getPredictions()[0].name);
+  test.ok(null === requ.commandAssignment.getValue());
+};
+
+exports.testTsv = function() {
+  update({ typed: 'tsv', cursor: { start: 3, end: 3 } });
+  test.is(   'VVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+
+  update({ typed: 'tsv ', cursor: { start: 4, end: 4 } });
+  test.is(   'VVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is(0, assignC.paramIndex);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+
+  update({ typed: 'tsv ', cursor: { start: 2, end: 2 } });
+  test.is(   'VVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+
+  update({ typed: 'tsv o', cursor: { start: 5, end: 5 } });
+  test.is(   'VVVVI', statuses);
+  test.is(Status.ERROR, status);
+  test.is(0, assignC.paramIndex);
+  test.is(2, assignC.getPredictions().length);
+  test.is(commands.option1, assignC.getPredictions()[0].value);
+  test.is(commands.option2, assignC.getPredictions()[1].value);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('o', assign1.getArg().text);
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsv option', cursor: { start: 10, end: 10 } });
+  test.is(   'VVVVIIIIII', statuses);
+  test.is(Status.ERROR, status);
+  test.is(0, assignC.paramIndex);
+  test.is(2, assignC.getPredictions().length);
+  test.is(commands.option1, assignC.getPredictions()[0].value);
+  test.is(commands.option2, assignC.getPredictions()[1].value);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option', assign1.getArg().text);
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsv option', cursor: { start: 1, end: 1 } });
+  test.is(   'VVVVEEEEEE', statuses);
+  test.is(Status.ERROR, status);
+  test.is(-1, assignC.paramIndex);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option', assign1.getArg().text);
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsv option ', cursor: { start: 11, end: 11 } });
+  test.is(   'VVVVEEEEEEV', statuses);
+  test.is(Status.ERROR, status);
+  test.is(1, assignC.paramIndex);
+  test.is(0, assignC.getPredictions().length);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option', assign1.getArg().text);
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsv option1', cursor: { start: 11, end: 11 } });
+  test.is(   'VVVVVVVVVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option1', assign1.getArg().text);
+  test.is(commands.option1, assign1.getValue());
+  test.is(0, assignC.paramIndex);
+
+  update({ typed: 'tsv option1 ', cursor: { start: 12, end: 12 } });
+  test.is(   'VVVVVVVVVVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option1', assign1.getArg().text);
+  test.is(commands.option1, assign1.getValue());
+  test.is(1, assignC.paramIndex);
+
+  update({ typed: 'tsv option1 6', cursor: { start: 13, end: 13 } });
+  test.is(   'VVVVVVVVVVVVV', statuses);
+  test.is(Status.VALID, status);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option1', assign1.getArg().text);
+  test.is(commands.option1, assign1.getValue());
+  test.is('6', assign2.getArg().text);
+  test.is(6, assign2.getValue());
+  test.is('number', typeof assign2.getValue());
+  test.is(1, assignC.paramIndex);
+
+  update({ typed: 'tsv option2 6', cursor: { start: 13, end: 13 } });
+  test.is(   'VVVVVVVVVVVVE', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsv', requ.commandAssignment.getValue().name);
+  test.is('option2', assign1.getArg().text);
+  test.is(commands.option2, assign1.getValue());
+  test.is('6', assign2.getArg().text);
+  test.is(null, assign2.getValue());
+  test.is(1, assignC.paramIndex);
+};
+
+exports.testInvalid = function() {
+  update({ typed: 'fred', cursor: { start: 4, end: 4 } });
+  test.is(   'EEEE', statuses);
+  test.is('fred', requ.commandAssignment.getArg().text);
+  test.is('', requ._unassigned.getArg().text);
+  test.is(-1, assignC.paramIndex);
+
+  update({ typed: 'fred ', cursor: { start: 5, end: 5 } });
+  test.is(   'EEEEV', statuses);
+  test.is('fred', requ.commandAssignment.getArg().text);
+  test.is('', requ._unassigned.getArg().text);
+  test.is(-1, assignC.paramIndex);
+
+  update({ typed: 'fred one', cursor: { start: 8, end: 8 } });
+  test.is(   'EEEEVEEE', statuses);
+  test.is('fred', requ.commandAssignment.getArg().text);
+  test.is('one', requ._unassigned.getArg().text);
+};
+
+exports.testSingleString = function() {
+  update({ typed: 'tsr', cursor: { start: 3, end: 3 } });
+  test.is(   'VVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsr', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  //test.is(undefined, assign1.getValue());
+  test.is(undefined, assign2);
+
+  update({ typed: 'tsr ', cursor: { start: 4, end: 4 } });
+  test.is(   'VVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsr', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  //test.is(undefined, assign1.getValue());
+  test.is(undefined, assign2);
+
+  update({ typed: 'tsr h', cursor: { start: 5, end: 5 } });
+  test.is(   'VVVVV', statuses);
+  test.is(Status.VALID, status);
+  test.is('tsr', requ.commandAssignment.getValue().name);
+  test.is('h', assign1.getArg().text);
+  test.is('h', assign1.getValue());
+
+  update({ typed: 'tsr "h h"', cursor: { start: 9, end: 9 } });
+  test.is(   'VVVVVVVVV', statuses);
+  test.is(Status.VALID, status);
+  test.is('tsr', requ.commandAssignment.getValue().name);
+  test.is('h h', assign1.getArg().text);
+  test.is('h h', assign1.getValue());
+
+  update({ typed: 'tsr h h h', cursor: { start: 9, end: 9 } });
+  test.is(   'VVVVVVVVV', statuses);
+  test.is('tsr', requ.commandAssignment.getValue().name);
+  test.is('h h h', assign1.getArg().text);
+  test.is('h h h', assign1.getValue());
+};
+
+// BUG 664203: Add test to see that a command without mandatory param -> ERROR
+
+exports.testSingleNumber = function() {
+  update({ typed: 'tsu', cursor: { start: 3, end: 3 } });
+  test.is(   'VVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsu', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsu ', cursor: { start: 4, end: 4 } });
+  test.is(   'VVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsu', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  test.is(null, assign1.getValue());
+
+  update({ typed: 'tsu 1', cursor: { start: 5, end: 5 } });
+  test.is(   'VVVVV', statuses);
+  test.is(Status.VALID, status);
+  test.is('tsu', requ.commandAssignment.getValue().name);
+  test.is('1', assign1.getArg().text);
+  test.is(1, assign1.getValue());
+  test.is('number', typeof assign1.getValue());
+
+  update({ typed: 'tsu x', cursor: { start: 5, end: 5 } });
+  test.is(   'VVVVE', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsu', requ.commandAssignment.getValue().name);
+  test.is('x', assign1.getArg().text);
+  test.is(null, assign1.getValue());
+};
+
+exports.testNestedCommand = function() {
+  update({ typed: 'tsn', cursor: { start: 3, end: 3 } });
+  test.is(   'III', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn', requ.commandAssignment.getValue().name);
+  test.is(undefined, assign1);
+
+  update({ typed: 'tsn ', cursor: { start: 4, end: 4 } });
+  test.is(   'IIIV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn', requ.commandAssignment.getValue().name);
+  test.is(undefined, assign1);
+
+  update({ typed: 'tsn x', cursor: { start: 5, end: 5 } });
+  test.is(   'EEEVE', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn x', requ.commandAssignment.getArg().text);
+  test.is(undefined, assign1);
+
+  update({ typed: 'tsn dif', cursor: { start: 7, end: 7 } });
+  test.is(   'VVVVVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn dif', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  //test.is(undefined, assign1.getValue());
+
+  update({ typed: 'tsn dif ', cursor: { start: 8, end: 8 } });
+  test.is(   'VVVVVVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn dif', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  //test.is(undefined, assign1.getValue());
+
+  update({ typed: 'tsn dif x', cursor: { start: 9, end: 9 } });
+  test.is(   'VVVVVVVVV', statuses);
+  test.is(Status.VALID, status);
+  test.is('tsn dif', requ.commandAssignment.getValue().name);
+  test.is('x', assign1.getArg().text);
+  test.is('x', assign1.getValue());
+
+  update({ typed: 'tsn ext', cursor: { start: 7, end: 7 } });
+  test.is(   'VVVVVVV', statuses);
+  test.is(Status.ERROR, status);
+  test.is('tsn ext', requ.commandAssignment.getValue().name);
+  //test.is(undefined, assign1.getArg());
+  //test.is(undefined, assign1.getValue());
+};
+
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/testHistory', ['require', 'exports', 'module' , 'test/assert', 'gcli/history'], function(require, exports, module) {
+
+var test = require('test/assert');
+var History = require('gcli/history').History;
+
+exports.setup = function() {
+};
+
+exports.shutdown = function() {
+};
+
+exports.testSimpleHistory = function () {
+  var history = new History({});
+  history.add('foo');
+  history.add('bar');
+  test.is('bar', history.backward());
+  test.is('foo', history.backward());
+
+  // Adding to the history again moves us back to the start of the history.
+  history.add('quux');
+  test.is('quux', history.backward());
+  test.is('bar', history.backward());
+  test.is('foo', history.backward());
+};
+
+exports.testBackwardsPastIndex = function () {
+  var history = new History({});
+  history.add('foo');
+  history.add('bar');
+  test.is('bar', history.backward());
+  test.is('foo', history.backward());
+
+  // Moving backwards past recorded history just keeps giving you the last
+  // item.
+  test.is('foo', history.backward());
+};
+
+exports.testForwardsPastIndex = function () {
+  var history = new History({});
+  history.add('foo');
+  history.add('bar');
+  test.is('bar', history.backward());
+  test.is('foo', history.backward());
+
+  // Going forward through the history again.
+  test.is('bar', history.forward());
+
+  // 'Present' time.
+  test.is('', history.forward());
+
+  // Going to the 'future' just keeps giving us the empty string.
+  test.is('', history.forward());
+};
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/testRequire', ['require', 'exports', 'module' , 'test/assert', 'gclitest/requirable'], function(require, exports, module) {
+
+var test = require('test/assert');
+
+
+exports.testWorking = function() {
+  // There are lots of requirement tests that we could be doing here
+  // The fact that we can get anything at all working is a testament to
+  // require doing what it should - we don't need to test the
+  var requireable = require('gclitest/requirable');
+  test.is('thing1', requireable.thing1);
+  test.is(2, requireable.thing2);
+  test.is(undefined, requireable.thing3);
+};
+
+exports.testDomains = function() {
+  var requireable = require('gclitest/requirable');
+  test.is(undefined, requireable.status);
+  requireable.setStatus(null);
+  test.is(null, requireable.getStatus());
+  test.is(undefined, requireable.status);
+  requireable.setStatus('42');
+  test.is('42', requireable.getStatus());
+  test.is(undefined, requireable.status);
+
+  if (define.Domain) {
+    var domain = new define.Domain();
+    var requireable2 = domain.require('gclitest/requirable');
+    test.is(undefined, requireable2.status);
+    test.is('initial', requireable2.getStatus());
+    requireable2.setStatus(999);
+    test.is(999, requireable2.getStatus());
+    test.is(undefined, requireable2.status);
+
+    test.is('42', requireable.getStatus());
+    test.is(undefined, requireable.status);
+  }
+};
+
+exports.testLeakage = function() {
+  var requireable = require('gclitest/requirable');
+  test.is(undefined, requireable.setup);
+  test.is(undefined, requireable.shutdown);
+  test.is(undefined, requireable.testWorking);
+};
+
+exports.testMultiImport = function() {
+  var r1 = require('gclitest/requirable');
+  var r2 = require('gclitest/requirable');
+  test.ok(r1 === r2);
+};
+
+exports.testUncompilable = function() {
+  // This test is commented out because it breaks the RequireJS module
+  // loader and because it causes console output and because testing failure
+  // cases such as this is something of a luxury
+  // It's not totally clear how a module loader should perform with unusable
+  // modules, however at least it should go into a flat spin ...
+  // GCLI mini_require reports an error as it should
+  /*
+  if (define.Domain) {
+    try {
+      var unrequireable = require('gclitest/unrequirable');
+      t.fail();
+    }
+    catch (ex) {
+      console.error(ex);
+    }
+  }
+  */
+};
+
+exports.testRecursive = function() {
+  // See Bug 658583
+  /*
+  var recurse = require('gclitest/recurse');
+  */
+};
+
+
+});
+/*
+ * Copyright 2009-2011 Mozilla Foundation and contributors
+ * Licensed under the New BSD license. See LICENSE.txt or:
+ * http://opensource.org/licenses/BSD-3-Clause
+ */
+
+define('gclitest/requirable', ['require', 'exports', 'module' ], function(require, exports, module) {
+
+  exports.thing1 = 'thing1';
+  exports.thing2 = 2;
+
+  var status = 'initial';
+  exports.setStatus = function(aStatus) { status = aStatus; };
+  exports.getStatus = function() { return status; };
+
+});
+
+registerCleanupFunction(function() {
+  Services.prefs.clearUserPref("devtools.gcli.enable");
+
+  obj = undefined;
+  define = undefined;
+  console = undefined;
+  Node = undefined;
+});
+
+function test() {
+  Services.prefs.setBoolPref("devtools.gcli.enable", true);
+  addTab("http://example.com/browser/browser/devtools/webconsole/test/browser/test-console.html");
+  browser.addEventListener("DOMContentLoaded", onLoad, false);
+}
+
+function onLoad() {
+  browser.removeEventListener("DOMContentLoaded", onLoad, false);
+
+  try {
+    openConsole();
+    require("gclitest/index");
+  }
+  catch (ex) {
+    console.error('Test Failure', ex);
+  }
+  finally {
+    closeConsole();
+    finishTest();
+  }
+}
